# 正则表达式基础
@(javascript)[regex, 正则表达式]

##  元字符


正则表达式语言由两种基本字符类型组成: `原意文本字符` 和 `元字符` 元字符使正则表达式具有处理能力。元字符指的是在**正则表达式中具有特殊意义的专用字符**。
- 常用的元字符如下
   <table>
   <thead>
   <th>代码</th>
   <th>含义</th>
   </thead>
   <tbody>
   <tr>
   
   <td> . </td> 
   <td>匹配除换行符以外的任意字符</td>
   </tr>
   <tr><td>\w</td><td>匹配字母或数字或下滑线或汉字</td></tr>
   <tr><td>\s</td><td>匹配任意的空白符</td></tr>
   <tr><td>\d</td><td>匹配数字</td></tr>
   <tr><td>\b</td><td>匹配单词的开始或结束</td></tr>
   <tr><td>^</td><td>匹配字符串的开始</td></tr>
     <tr><td>$</td><td>匹配字符串的结束</td></tr>
     <tr><td>|</td><td>匹配子表达式</td></tr>
     <tr><td>?</td><td>可选项元素</td></tr>
   </tbody>
   </table>

| 代码     | 含义|
| :-------- |:--------|
|.|匹配除换行符以外的任意字符|
|\w|匹配字母或数字或下滑线或汉字|
|\d|匹配任意的空白符|
|\b|匹配单词的开始或结束|
|^|匹配字符串的开始|
|$|匹配字符串的结束|
| \| |匹配子表达式  |
|?|可选项元素|
|{n,m}|匹配的次数为n-m次|
|{n,}|匹配的次数至少为n次|
现在举例如下：
假如我们要匹配以1开头的五位数到7位数  可以写成 `1\d{5,6}$ ` 
假如我们要找以cat开头的字符，可以写成`^cat`
假如我们要找以cat结束的字符串，可以写成`$cat`


**假如我们要查找`元字符` 本身呢？** 如我们要查找 `.` 或者`$` 我们只能使用转义符`\` 来取消这些字符的特殊含义。如 我们要匹配`.` 我们应该使用 `\.` 。

## 字符组
字符组是用来匹配若干个字符 。假如我们需要搜索的字符是 **skull** ,但是又不确定是**skulk**，那我们可以使用正则表达式结构体`[....]` ,它容许我们列出在某处期望匹配的字符。`[k]` 匹配字符**k**,而`[km]` 能匹配字符**k**或者**m** 。所以使用 `skul[lk]` 既能匹配**skull**，也能匹配**skulk**。
在字符组内部，字符组元字符 `-` 表示一个范围：
举例如下 `<H[1-6]>` 与`<H[123456]` 所表达的意思是一样的。`[0-9]` 和`[a-z]`是常用的匹配数字和小写字母的简便方式。多重范围的匹配也是容许的。例如 `[012345abcdefABC]` 可以写成`[0-5a-fA-C]`
也可以写成`[a-f0-5A-C]` 

-  **顺序是无所谓的**
-  **只有在字符组内部，连字符才是元字符--否则它就只能匹配普通的连字符号。在字符组中，问号和点号起不到元字符的作用**。

如下面的例子 `[0-9A-Z!.?]` 的含义是匹配一个数字，大写字母，下划线，感叹号，点号，或者是问号。

### 排除型字符组
用`[^...]` 取代 `[...]` 这个字符组就会匹配任何未列出的字符。例如 `[^1-6]` 匹配**除了1到6以外的任何字符**。从上面的举例，我们可以发现`^` 在字符组内部的含义与在行的起始是不一样的。

**下面举一个例子关于^的特殊情况的例子。**
``` javascript
/**
 *@description 使用javascript语言来测试 排除型字符组
*/
var regTest = /q[^u]/;
var stringTest = 'Iraq';
var stringTestOne = 'Iraq ';//Iraq后面有一个空格
var result = regTest.test(stringTest);
console.log(result);
result = regTest.test(stringTestOne);
console.log(result);

//输出的结果为 
//false
// true
```
从上面的例子可以 ，正则表达式要求q之后紧跟一个u以外的字符。这就排除了q处在行尾的情况。由于字符串都行尾都有换行符，但是正则表达式并没有处理。

### 用点号来匹配任意字符
元字符`.` (通常称为点号dot)是用来匹配任意字符组的简便写法。例如我们要搜索 03/19/76  03.19.76  或03-19-76，不怕麻烦的话，可以写成`03[-./]19[-./]76` 也可以简单地尝试 `03.19.76` 
**注意换行符`\n`  点号匹配不了，但是制表符`\t` 能够匹配** 
## 多选结构
### 匹配任意子表达式
`|` 是一个非常简洁的元字符，它的意思是**‘或’**，依靠它，我们能够把不同的子表达式组合成一个总的表达式，而这个总的表达式又能够匹配任意的子表达式。子表达式称为**多选分支(alternative)**
对于`skul[lk]` 表达式，我们可以写成 `skull|skulk` ,但是写成`skul[l|k]` 还能够匹配skul| ,在字符组中 `|` 不起任何作用。我们还可以添加括号 `skul(l|k)` = `skull|skulk` = `skul[l|k]`

### 忽略大小写
在javascript 中正则表达式忽略大小写使用`i`字母 ， 

### 可选元素选项

我们看color和colour的匹配。它们的区别在于，后面的单词比前面的多一个u,我们可以使用`colou?r` 来解决这个问题。元字符`?` 代表***可选项*** 。把它加在某个字符后面，就表示此处容许出现这个字符，不过它的出现并非匹配成功的必要条件。 **u?** 这个字符与我们之前看到的元字符都不相同，它只作用于之前紧邻的元素。因此，`colou?r`  的意思是匹配c，然后匹配o，然后匹配l，然后匹配o ,然后匹配u , 然后是u? ,最后是r.
 u?  肯定是能够匹配成功的。有时侯它会匹配一个u, 有时不匹配任何字符。关键在于，无论u是否出现，匹配都是成功的。
### 规定重现的次数的范围：区间
有些版本的正则表达式支持使用元字符来定义重现次数的区间 `....{min,max}` 。这种表示方法称为**区间量词** 例如`...{3,12}` 表示容许的次数在3到12之间。
### 重复出现。
`+`和`*` 
元字符 `+`表示之前紧邻的元素出现一次或多次。而`*`表示之前紧邻的元素出现任意次。也就是意思说“匹配尽可能多的元素，但如果连一次匹配都无法完成，也不要紧”。

我们现在使用上面的知识来匹配 表示时刻的文字，例如 “05:20 am” 或者"12:03 pm"
正则表达式可以这样写
 **[0-9]?[0-9]:[0-9][0-9].(am|pm)**
 这个表达式可以匹配**05:20 am** 但是也能匹配**99:99 am**
 那我们怎么实现更严谨的匹配24小时制的呢？
 **(([01][0-9])|(2[0-3])):[0-5][0-9].(am|pm)**  该正则表达式能够精确的匹配24小时制的时间
 
 






